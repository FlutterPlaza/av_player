// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#undef _HAS_EXCEPTIONS

#include "messages.g.h"

#include <flutter/basic_message_channel.h>
#include <flutter/binary_messenger.h>
#include <flutter/encodable_value.h>
#include <flutter/standard_message_codec.h>

#include <map>
#include <optional>
#include <string>

namespace av_player_windows {
using flutter::BasicMessageChannel;
using flutter::CustomEncodableValue;
using flutter::EncodableList;
using flutter::EncodableMap;
using flutter::EncodableValue;

FlutterError CreateConnectionError(const std::string channel_name) {
  return FlutterError(
      "channel-error",
      "Unable to establish connection on channel: '" + channel_name + "'.",
      EncodableValue(""));
}

// VideoSourceMessage

VideoSourceMessage::VideoSourceMessage(const SourceType& type)
 : type_(type) {}

VideoSourceMessage::VideoSourceMessage(
  const SourceType& type,
  const std::string* url,
  const EncodableMap* headers,
  const std::string* asset_path,
  const std::string* file_path)
 : type_(type),
    url_(url ? std::optional<std::string>(*url) : std::nullopt),
    headers_(headers ? std::optional<EncodableMap>(*headers) : std::nullopt),
    asset_path_(asset_path ? std::optional<std::string>(*asset_path) : std::nullopt),
    file_path_(file_path ? std::optional<std::string>(*file_path) : std::nullopt) {}

const SourceType& VideoSourceMessage::type() const {
  return type_;
}

void VideoSourceMessage::set_type(const SourceType& value_arg) {
  type_ = value_arg;
}


const std::string* VideoSourceMessage::url() const {
  return url_ ? &(*url_) : nullptr;
}

void VideoSourceMessage::set_url(const std::string_view* value_arg) {
  url_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_url(std::string_view value_arg) {
  url_ = value_arg;
}


const EncodableMap* VideoSourceMessage::headers() const {
  return headers_ ? &(*headers_) : nullptr;
}

void VideoSourceMessage::set_headers(const EncodableMap* value_arg) {
  headers_ = value_arg ? std::optional<EncodableMap>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_headers(const EncodableMap& value_arg) {
  headers_ = value_arg;
}


const std::string* VideoSourceMessage::asset_path() const {
  return asset_path_ ? &(*asset_path_) : nullptr;
}

void VideoSourceMessage::set_asset_path(const std::string_view* value_arg) {
  asset_path_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_asset_path(std::string_view value_arg) {
  asset_path_ = value_arg;
}


const std::string* VideoSourceMessage::file_path() const {
  return file_path_ ? &(*file_path_) : nullptr;
}

void VideoSourceMessage::set_file_path(const std::string_view* value_arg) {
  file_path_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void VideoSourceMessage::set_file_path(std::string_view value_arg) {
  file_path_ = value_arg;
}


EncodableList VideoSourceMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(5);
  list.push_back(CustomEncodableValue(type_));
  list.push_back(url_ ? EncodableValue(*url_) : EncodableValue());
  list.push_back(headers_ ? EncodableValue(*headers_) : EncodableValue());
  list.push_back(asset_path_ ? EncodableValue(*asset_path_) : EncodableValue());
  list.push_back(file_path_ ? EncodableValue(*file_path_) : EncodableValue());
  return list;
}

VideoSourceMessage VideoSourceMessage::FromEncodableList(const EncodableList& list) {
  VideoSourceMessage decoded(
    std::any_cast<const SourceType&>(std::get<CustomEncodableValue>(list[0])));
  auto& encodable_url = list[1];
  if (!encodable_url.IsNull()) {
    decoded.set_url(std::get<std::string>(encodable_url));
  }
  auto& encodable_headers = list[2];
  if (!encodable_headers.IsNull()) {
    decoded.set_headers(std::get<EncodableMap>(encodable_headers));
  }
  auto& encodable_asset_path = list[3];
  if (!encodable_asset_path.IsNull()) {
    decoded.set_asset_path(std::get<std::string>(encodable_asset_path));
  }
  auto& encodable_file_path = list[4];
  if (!encodable_file_path.IsNull()) {
    decoded.set_file_path(std::get<std::string>(encodable_file_path));
  }
  return decoded;
}

// MediaMetadataMessage

MediaMetadataMessage::MediaMetadataMessage() {}

MediaMetadataMessage::MediaMetadataMessage(
  const std::string* title,
  const std::string* artist,
  const std::string* album,
  const std::string* artwork_url)
 : title_(title ? std::optional<std::string>(*title) : std::nullopt),
    artist_(artist ? std::optional<std::string>(*artist) : std::nullopt),
    album_(album ? std::optional<std::string>(*album) : std::nullopt),
    artwork_url_(artwork_url ? std::optional<std::string>(*artwork_url) : std::nullopt) {}

const std::string* MediaMetadataMessage::title() const {
  return title_ ? &(*title_) : nullptr;
}

void MediaMetadataMessage::set_title(const std::string_view* value_arg) {
  title_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_title(std::string_view value_arg) {
  title_ = value_arg;
}


const std::string* MediaMetadataMessage::artist() const {
  return artist_ ? &(*artist_) : nullptr;
}

void MediaMetadataMessage::set_artist(const std::string_view* value_arg) {
  artist_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_artist(std::string_view value_arg) {
  artist_ = value_arg;
}


const std::string* MediaMetadataMessage::album() const {
  return album_ ? &(*album_) : nullptr;
}

void MediaMetadataMessage::set_album(const std::string_view* value_arg) {
  album_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_album(std::string_view value_arg) {
  album_ = value_arg;
}


const std::string* MediaMetadataMessage::artwork_url() const {
  return artwork_url_ ? &(*artwork_url_) : nullptr;
}

void MediaMetadataMessage::set_artwork_url(const std::string_view* value_arg) {
  artwork_url_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void MediaMetadataMessage::set_artwork_url(std::string_view value_arg) {
  artwork_url_ = value_arg;
}


EncodableList MediaMetadataMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(title_ ? EncodableValue(*title_) : EncodableValue());
  list.push_back(artist_ ? EncodableValue(*artist_) : EncodableValue());
  list.push_back(album_ ? EncodableValue(*album_) : EncodableValue());
  list.push_back(artwork_url_ ? EncodableValue(*artwork_url_) : EncodableValue());
  return list;
}

MediaMetadataMessage MediaMetadataMessage::FromEncodableList(const EncodableList& list) {
  MediaMetadataMessage decoded;
  auto& encodable_title = list[0];
  if (!encodable_title.IsNull()) {
    decoded.set_title(std::get<std::string>(encodable_title));
  }
  auto& encodable_artist = list[1];
  if (!encodable_artist.IsNull()) {
    decoded.set_artist(std::get<std::string>(encodable_artist));
  }
  auto& encodable_album = list[2];
  if (!encodable_album.IsNull()) {
    decoded.set_album(std::get<std::string>(encodable_album));
  }
  auto& encodable_artwork_url = list[3];
  if (!encodable_artwork_url.IsNull()) {
    decoded.set_artwork_url(std::get<std::string>(encodable_artwork_url));
  }
  return decoded;
}

// EnterPipRequest

EnterPipRequest::EnterPipRequest(int64_t player_id)
 : player_id_(player_id) {}

EnterPipRequest::EnterPipRequest(
  int64_t player_id,
  const double* aspect_ratio)
 : player_id_(player_id),
    aspect_ratio_(aspect_ratio ? std::optional<double>(*aspect_ratio) : std::nullopt) {}

int64_t EnterPipRequest::player_id() const {
  return player_id_;
}

void EnterPipRequest::set_player_id(int64_t value_arg) {
  player_id_ = value_arg;
}


const double* EnterPipRequest::aspect_ratio() const {
  return aspect_ratio_ ? &(*aspect_ratio_) : nullptr;
}

void EnterPipRequest::set_aspect_ratio(const double* value_arg) {
  aspect_ratio_ = value_arg ? std::optional<double>(*value_arg) : std::nullopt;
}

void EnterPipRequest::set_aspect_ratio(double value_arg) {
  aspect_ratio_ = value_arg;
}


EncodableList EnterPipRequest::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(player_id_));
  list.push_back(aspect_ratio_ ? EncodableValue(*aspect_ratio_) : EncodableValue());
  return list;
}

EnterPipRequest EnterPipRequest::FromEncodableList(const EncodableList& list) {
  EnterPipRequest decoded(
    std::get<int64_t>(list[0]));
  auto& encodable_aspect_ratio = list[1];
  if (!encodable_aspect_ratio.IsNull()) {
    decoded.set_aspect_ratio(std::get<double>(encodable_aspect_ratio));
  }
  return decoded;
}

// MediaMetadataRequest

MediaMetadataRequest::MediaMetadataRequest(
  int64_t player_id,
  const MediaMetadataMessage& metadata)
 : player_id_(player_id),
    metadata_(std::make_unique<MediaMetadataMessage>(metadata)) {}

MediaMetadataRequest::MediaMetadataRequest(const MediaMetadataRequest& other)
 : player_id_(other.player_id_),
    metadata_(std::make_unique<MediaMetadataMessage>(*other.metadata_)) {}

MediaMetadataRequest& MediaMetadataRequest::operator=(const MediaMetadataRequest& other) {
  player_id_ = other.player_id_;
  metadata_ = std::make_unique<MediaMetadataMessage>(*other.metadata_);
  return *this;
}

int64_t MediaMetadataRequest::player_id() const {
  return player_id_;
}

void MediaMetadataRequest::set_player_id(int64_t value_arg) {
  player_id_ = value_arg;
}


const MediaMetadataMessage& MediaMetadataRequest::metadata() const {
  return *metadata_;
}

void MediaMetadataRequest::set_metadata(const MediaMetadataMessage& value_arg) {
  metadata_ = std::make_unique<MediaMetadataMessage>(value_arg);
}


EncodableList MediaMetadataRequest::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(player_id_));
  list.push_back(CustomEncodableValue(*metadata_));
  return list;
}

MediaMetadataRequest MediaMetadataRequest::FromEncodableList(const EncodableList& list) {
  MediaMetadataRequest decoded(
    std::get<int64_t>(list[0]),
    std::any_cast<const MediaMetadataMessage&>(std::get<CustomEncodableValue>(list[1])));
  return decoded;
}

// AbrConfigMessage

AbrConfigMessage::AbrConfigMessage() {}

AbrConfigMessage::AbrConfigMessage(
  const int64_t* max_bitrate_bps,
  const int64_t* min_bitrate_bps,
  const int64_t* preferred_max_width,
  const int64_t* preferred_max_height)
 : max_bitrate_bps_(max_bitrate_bps ? std::optional<int64_t>(*max_bitrate_bps) : std::nullopt),
    min_bitrate_bps_(min_bitrate_bps ? std::optional<int64_t>(*min_bitrate_bps) : std::nullopt),
    preferred_max_width_(preferred_max_width ? std::optional<int64_t>(*preferred_max_width) : std::nullopt),
    preferred_max_height_(preferred_max_height ? std::optional<int64_t>(*preferred_max_height) : std::nullopt) {}

const int64_t* AbrConfigMessage::max_bitrate_bps() const {
  return max_bitrate_bps_ ? &(*max_bitrate_bps_) : nullptr;
}

void AbrConfigMessage::set_max_bitrate_bps(const int64_t* value_arg) {
  max_bitrate_bps_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void AbrConfigMessage::set_max_bitrate_bps(int64_t value_arg) {
  max_bitrate_bps_ = value_arg;
}


const int64_t* AbrConfigMessage::min_bitrate_bps() const {
  return min_bitrate_bps_ ? &(*min_bitrate_bps_) : nullptr;
}

void AbrConfigMessage::set_min_bitrate_bps(const int64_t* value_arg) {
  min_bitrate_bps_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void AbrConfigMessage::set_min_bitrate_bps(int64_t value_arg) {
  min_bitrate_bps_ = value_arg;
}


const int64_t* AbrConfigMessage::preferred_max_width() const {
  return preferred_max_width_ ? &(*preferred_max_width_) : nullptr;
}

void AbrConfigMessage::set_preferred_max_width(const int64_t* value_arg) {
  preferred_max_width_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void AbrConfigMessage::set_preferred_max_width(int64_t value_arg) {
  preferred_max_width_ = value_arg;
}


const int64_t* AbrConfigMessage::preferred_max_height() const {
  return preferred_max_height_ ? &(*preferred_max_height_) : nullptr;
}

void AbrConfigMessage::set_preferred_max_height(const int64_t* value_arg) {
  preferred_max_height_ = value_arg ? std::optional<int64_t>(*value_arg) : std::nullopt;
}

void AbrConfigMessage::set_preferred_max_height(int64_t value_arg) {
  preferred_max_height_ = value_arg;
}


EncodableList AbrConfigMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(4);
  list.push_back(max_bitrate_bps_ ? EncodableValue(*max_bitrate_bps_) : EncodableValue());
  list.push_back(min_bitrate_bps_ ? EncodableValue(*min_bitrate_bps_) : EncodableValue());
  list.push_back(preferred_max_width_ ? EncodableValue(*preferred_max_width_) : EncodableValue());
  list.push_back(preferred_max_height_ ? EncodableValue(*preferred_max_height_) : EncodableValue());
  return list;
}

AbrConfigMessage AbrConfigMessage::FromEncodableList(const EncodableList& list) {
  AbrConfigMessage decoded;
  auto& encodable_max_bitrate_bps = list[0];
  if (!encodable_max_bitrate_bps.IsNull()) {
    decoded.set_max_bitrate_bps(std::get<int64_t>(encodable_max_bitrate_bps));
  }
  auto& encodable_min_bitrate_bps = list[1];
  if (!encodable_min_bitrate_bps.IsNull()) {
    decoded.set_min_bitrate_bps(std::get<int64_t>(encodable_min_bitrate_bps));
  }
  auto& encodable_preferred_max_width = list[2];
  if (!encodable_preferred_max_width.IsNull()) {
    decoded.set_preferred_max_width(std::get<int64_t>(encodable_preferred_max_width));
  }
  auto& encodable_preferred_max_height = list[3];
  if (!encodable_preferred_max_height.IsNull()) {
    decoded.set_preferred_max_height(std::get<int64_t>(encodable_preferred_max_height));
  }
  return decoded;
}

// SetAbrConfigRequest

SetAbrConfigRequest::SetAbrConfigRequest(
  int64_t player_id,
  const AbrConfigMessage& config)
 : player_id_(player_id),
    config_(std::make_unique<AbrConfigMessage>(config)) {}

SetAbrConfigRequest::SetAbrConfigRequest(const SetAbrConfigRequest& other)
 : player_id_(other.player_id_),
    config_(std::make_unique<AbrConfigMessage>(*other.config_)) {}

SetAbrConfigRequest& SetAbrConfigRequest::operator=(const SetAbrConfigRequest& other) {
  player_id_ = other.player_id_;
  config_ = std::make_unique<AbrConfigMessage>(*other.config_);
  return *this;
}

int64_t SetAbrConfigRequest::player_id() const {
  return player_id_;
}

void SetAbrConfigRequest::set_player_id(int64_t value_arg) {
  player_id_ = value_arg;
}


const AbrConfigMessage& SetAbrConfigRequest::config() const {
  return *config_;
}

void SetAbrConfigRequest::set_config(const AbrConfigMessage& value_arg) {
  config_ = std::make_unique<AbrConfigMessage>(value_arg);
}


EncodableList SetAbrConfigRequest::ToEncodableList() const {
  EncodableList list;
  list.reserve(2);
  list.push_back(EncodableValue(player_id_));
  list.push_back(CustomEncodableValue(*config_));
  return list;
}

SetAbrConfigRequest SetAbrConfigRequest::FromEncodableList(const EncodableList& list) {
  SetAbrConfigRequest decoded(
    std::get<int64_t>(list[0]),
    std::any_cast<const AbrConfigMessage&>(std::get<CustomEncodableValue>(list[1])));
  return decoded;
}

// DecoderInfoMessage

DecoderInfoMessage::DecoderInfoMessage(bool is_hardware_accelerated)
 : is_hardware_accelerated_(is_hardware_accelerated) {}

DecoderInfoMessage::DecoderInfoMessage(
  bool is_hardware_accelerated,
  const std::string* decoder_name,
  const std::string* codec)
 : is_hardware_accelerated_(is_hardware_accelerated),
    decoder_name_(decoder_name ? std::optional<std::string>(*decoder_name) : std::nullopt),
    codec_(codec ? std::optional<std::string>(*codec) : std::nullopt) {}

bool DecoderInfoMessage::is_hardware_accelerated() const {
  return is_hardware_accelerated_;
}

void DecoderInfoMessage::set_is_hardware_accelerated(bool value_arg) {
  is_hardware_accelerated_ = value_arg;
}


const std::string* DecoderInfoMessage::decoder_name() const {
  return decoder_name_ ? &(*decoder_name_) : nullptr;
}

void DecoderInfoMessage::set_decoder_name(const std::string_view* value_arg) {
  decoder_name_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void DecoderInfoMessage::set_decoder_name(std::string_view value_arg) {
  decoder_name_ = value_arg;
}


const std::string* DecoderInfoMessage::codec() const {
  return codec_ ? &(*codec_) : nullptr;
}

void DecoderInfoMessage::set_codec(const std::string_view* value_arg) {
  codec_ = value_arg ? std::optional<std::string>(*value_arg) : std::nullopt;
}

void DecoderInfoMessage::set_codec(std::string_view value_arg) {
  codec_ = value_arg;
}


EncodableList DecoderInfoMessage::ToEncodableList() const {
  EncodableList list;
  list.reserve(3);
  list.push_back(EncodableValue(is_hardware_accelerated_));
  list.push_back(decoder_name_ ? EncodableValue(*decoder_name_) : EncodableValue());
  list.push_back(codec_ ? EncodableValue(*codec_) : EncodableValue());
  return list;
}

DecoderInfoMessage DecoderInfoMessage::FromEncodableList(const EncodableList& list) {
  DecoderInfoMessage decoded(
    std::get<bool>(list[0]));
  auto& encodable_decoder_name = list[1];
  if (!encodable_decoder_name.IsNull()) {
    decoded.set_decoder_name(std::get<std::string>(encodable_decoder_name));
  }
  auto& encodable_codec = list[2];
  if (!encodable_codec.IsNull()) {
    decoded.set_codec(std::get<std::string>(encodable_codec));
  }
  return decoded;
}


PigeonInternalCodecSerializer::PigeonInternalCodecSerializer() {}

EncodableValue PigeonInternalCodecSerializer::ReadValueOfType(
  uint8_t type,
  flutter::ByteStreamReader* stream) const {
  switch (type) {
    case 129: {
        const auto& encodable_enum_arg = ReadValue(stream);
        const int64_t enum_arg_value = encodable_enum_arg.IsNull() ? 0 : encodable_enum_arg.LongValue();
        return encodable_enum_arg.IsNull() ? EncodableValue() : CustomEncodableValue(static_cast<SourceType>(enum_arg_value));
      }
    case 130: {
        return CustomEncodableValue(VideoSourceMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 131: {
        return CustomEncodableValue(MediaMetadataMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 132: {
        return CustomEncodableValue(EnterPipRequest::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 133: {
        return CustomEncodableValue(MediaMetadataRequest::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 134: {
        return CustomEncodableValue(AbrConfigMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 135: {
        return CustomEncodableValue(SetAbrConfigRequest::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    case 136: {
        return CustomEncodableValue(DecoderInfoMessage::FromEncodableList(std::get<EncodableList>(ReadValue(stream))));
      }
    default:
      return flutter::StandardCodecSerializer::ReadValueOfType(type, stream);
    }
}

void PigeonInternalCodecSerializer::WriteValue(
  const EncodableValue& value,
  flutter::ByteStreamWriter* stream) const {
  if (const CustomEncodableValue* custom_value = std::get_if<CustomEncodableValue>(&value)) {
    if (custom_value->type() == typeid(SourceType)) {
      stream->WriteByte(129);
      WriteValue(EncodableValue(static_cast<int>(std::any_cast<SourceType>(*custom_value))), stream);
      return;
    }
    if (custom_value->type() == typeid(VideoSourceMessage)) {
      stream->WriteByte(130);
      WriteValue(EncodableValue(std::any_cast<VideoSourceMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaMetadataMessage)) {
      stream->WriteByte(131);
      WriteValue(EncodableValue(std::any_cast<MediaMetadataMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(EnterPipRequest)) {
      stream->WriteByte(132);
      WriteValue(EncodableValue(std::any_cast<EnterPipRequest>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(MediaMetadataRequest)) {
      stream->WriteByte(133);
      WriteValue(EncodableValue(std::any_cast<MediaMetadataRequest>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(AbrConfigMessage)) {
      stream->WriteByte(134);
      WriteValue(EncodableValue(std::any_cast<AbrConfigMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(SetAbrConfigRequest)) {
      stream->WriteByte(135);
      WriteValue(EncodableValue(std::any_cast<SetAbrConfigRequest>(*custom_value).ToEncodableList()), stream);
      return;
    }
    if (custom_value->type() == typeid(DecoderInfoMessage)) {
      stream->WriteByte(136);
      WriteValue(EncodableValue(std::any_cast<DecoderInfoMessage>(*custom_value).ToEncodableList()), stream);
      return;
    }
  }
  flutter::StandardCodecSerializer::WriteValue(value, stream);
}

/// The codec used by AvPlayerHostApi.
const flutter::StandardMessageCodec& AvPlayerHostApi::GetCodec() {
  return flutter::StandardMessageCodec::GetInstance(&PigeonInternalCodecSerializer::GetInstance());
}

// Sets up an instance of `AvPlayerHostApi` to handle messages through the `binary_messenger`.
void AvPlayerHostApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  AvPlayerHostApi* api) {
  AvPlayerHostApi::SetUp(binary_messenger, api, "");
}

void AvPlayerHostApi::SetUp(
  flutter::BinaryMessenger* binary_messenger,
  AvPlayerHostApi* api,
  const std::string& message_channel_suffix) {
  const std::string prepended_suffix = message_channel_suffix.length() > 0 ? std::string(".") + message_channel_suffix : "";
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.create" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_source_arg = args.at(0);
          if (encodable_source_arg.IsNull()) {
            reply(WrapError("source_arg unexpectedly null."));
            return;
          }
          const auto& source_arg = std::any_cast<const VideoSourceMessage&>(std::get<CustomEncodableValue>(encodable_source_arg));
          api->Create(source_arg, [reply](ErrorOr<int64_t>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.dispose" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Dispose(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.play" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Play(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.pause" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->Pause(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.seekTo" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_position_ms_arg = args.at(1);
          if (encodable_position_ms_arg.IsNull()) {
            reply(WrapError("position_ms_arg unexpectedly null."));
            return;
          }
          const int64_t position_ms_arg = encodable_position_ms_arg.LongValue();
          api->SeekTo(player_id_arg, position_ms_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setPlaybackSpeed" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_speed_arg = args.at(1);
          if (encodable_speed_arg.IsNull()) {
            reply(WrapError("speed_arg unexpectedly null."));
            return;
          }
          const auto& speed_arg = std::get<double>(encodable_speed_arg);
          api->SetPlaybackSpeed(player_id_arg, speed_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setLooping" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_looping_arg = args.at(1);
          if (encodable_looping_arg.IsNull()) {
            reply(WrapError("looping_arg unexpectedly null."));
            return;
          }
          const auto& looping_arg = std::get<bool>(encodable_looping_arg);
          api->SetLooping(player_id_arg, looping_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_volume_arg = args.at(1);
          if (encodable_volume_arg.IsNull()) {
            reply(WrapError("volume_arg unexpectedly null."));
            return;
          }
          const auto& volume_arg = std::get<double>(encodable_volume_arg);
          api->SetVolume(player_id_arg, volume_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.isPipAvailable" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->IsPipAvailable([reply](ErrorOr<bool>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.enterPip" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_request_arg = args.at(0);
          if (encodable_request_arg.IsNull()) {
            reply(WrapError("request_arg unexpectedly null."));
            return;
          }
          const auto& request_arg = std::any_cast<const EnterPipRequest&>(std::get<CustomEncodableValue>(encodable_request_arg));
          api->EnterPip(request_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.exitPip" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->ExitPip(player_id_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setMediaMetadata" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_request_arg = args.at(0);
          if (encodable_request_arg.IsNull()) {
            reply(WrapError("request_arg unexpectedly null."));
            return;
          }
          const auto& request_arg = std::any_cast<const MediaMetadataRequest&>(std::get<CustomEncodableValue>(encodable_request_arg));
          api->SetMediaMetadata(request_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setNotificationEnabled" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          const auto& encodable_enabled_arg = args.at(1);
          if (encodable_enabled_arg.IsNull()) {
            reply(WrapError("enabled_arg unexpectedly null."));
            return;
          }
          const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
          api->SetNotificationEnabled(player_id_arg, enabled_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setSystemVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_volume_arg = args.at(0);
          if (encodable_volume_arg.IsNull()) {
            reply(WrapError("volume_arg unexpectedly null."));
            return;
          }
          const auto& volume_arg = std::get<double>(encodable_volume_arg);
          api->SetSystemVolume(volume_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.getSystemVolume" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetSystemVolume([reply](ErrorOr<double>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setScreenBrightness" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_brightness_arg = args.at(0);
          if (encodable_brightness_arg.IsNull()) {
            reply(WrapError("brightness_arg unexpectedly null."));
            return;
          }
          const auto& brightness_arg = std::get<double>(encodable_brightness_arg);
          api->SetScreenBrightness(brightness_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.getScreenBrightness" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          api->GetScreenBrightness([reply](ErrorOr<double>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setWakelock" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_enabled_arg = args.at(0);
          if (encodable_enabled_arg.IsNull()) {
            reply(WrapError("enabled_arg unexpectedly null."));
            return;
          }
          const auto& enabled_arg = std::get<bool>(encodable_enabled_arg);
          api->SetWakelock(enabled_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.setAbrConfig" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_request_arg = args.at(0);
          if (encodable_request_arg.IsNull()) {
            reply(WrapError("request_arg unexpectedly null."));
            return;
          }
          const auto& request_arg = std::any_cast<const SetAbrConfigRequest&>(std::get<CustomEncodableValue>(encodable_request_arg));
          api->SetAbrConfig(request_arg, [reply](std::optional<FlutterError>&& output) {
            if (output.has_value()) {
              reply(WrapError(output.value()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(EncodableValue());
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
  {
    BasicMessageChannel<> channel(binary_messenger, "dev.flutter.pigeon.av_player.AvPlayerHostApi.getDecoderInfo" + prepended_suffix, &GetCodec());
    if (api != nullptr) {
      channel.SetMessageHandler([api](const EncodableValue& message, const flutter::MessageReply<EncodableValue>& reply) {
        try {
          const auto& args = std::get<EncodableList>(message);
          const auto& encodable_player_id_arg = args.at(0);
          if (encodable_player_id_arg.IsNull()) {
            reply(WrapError("player_id_arg unexpectedly null."));
            return;
          }
          const int64_t player_id_arg = encodable_player_id_arg.LongValue();
          api->GetDecoderInfo(player_id_arg, [reply](ErrorOr<DecoderInfoMessage>&& output) {
            if (output.has_error()) {
              reply(WrapError(output.error()));
              return;
            }
            EncodableList wrapped;
            wrapped.push_back(CustomEncodableValue(std::move(output).TakeValue()));
            reply(EncodableValue(std::move(wrapped)));
          });
        } catch (const std::exception& exception) {
          reply(WrapError(exception.what()));
        }
      });
    } else {
      channel.SetMessageHandler(nullptr);
    }
  }
}

EncodableValue AvPlayerHostApi::WrapError(std::string_view error_message) {
  return EncodableValue(EncodableList{
    EncodableValue(std::string(error_message)),
    EncodableValue("Error"),
    EncodableValue()
  });
}

EncodableValue AvPlayerHostApi::WrapError(const FlutterError& error) {
  return EncodableValue(EncodableList{
    EncodableValue(error.code()),
    EncodableValue(error.message()),
    error.details()
  });
}

}  // namespace av_player_windows
