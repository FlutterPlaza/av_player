// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum SourceType: Int {
  case network = 0
  case asset = 1
  case file = 2
}

/// Generated class from Pigeon that represents data sent in messages.
struct VideoSourceMessage {
  var type: SourceType
  var url: String? = nil
  var headers: [String?: String?]? = nil
  var assetPath: String? = nil
  var filePath: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoSourceMessage? {
    let type = pigeonVar_list[0] as! SourceType
    let url: String? = nilOrValue(pigeonVar_list[1])
    let headers: [String?: String?]? = nilOrValue(pigeonVar_list[2])
    let assetPath: String? = nilOrValue(pigeonVar_list[3])
    let filePath: String? = nilOrValue(pigeonVar_list[4])

    return VideoSourceMessage(
      type: type,
      url: url,
      headers: headers,
      assetPath: assetPath,
      filePath: filePath
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      url,
      headers,
      assetPath,
      filePath,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MediaMetadataMessage {
  var title: String? = nil
  var artist: String? = nil
  var album: String? = nil
  var artworkUrl: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MediaMetadataMessage? {
    let title: String? = nilOrValue(pigeonVar_list[0])
    let artist: String? = nilOrValue(pigeonVar_list[1])
    let album: String? = nilOrValue(pigeonVar_list[2])
    let artworkUrl: String? = nilOrValue(pigeonVar_list[3])

    return MediaMetadataMessage(
      title: title,
      artist: artist,
      album: album,
      artworkUrl: artworkUrl
    )
  }
  func toList() -> [Any?] {
    return [
      title,
      artist,
      album,
      artworkUrl,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct EnterPipRequest {
  var playerId: Int64
  var aspectRatio: Double? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> EnterPipRequest? {
    let playerId = pigeonVar_list[0] as! Int64
    let aspectRatio: Double? = nilOrValue(pigeonVar_list[1])

    return EnterPipRequest(
      playerId: playerId,
      aspectRatio: aspectRatio
    )
  }
  func toList() -> [Any?] {
    return [
      playerId,
      aspectRatio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MediaMetadataRequest {
  var playerId: Int64
  var metadata: MediaMetadataMessage


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MediaMetadataRequest? {
    let playerId = pigeonVar_list[0] as! Int64
    let metadata = pigeonVar_list[1] as! MediaMetadataMessage

    return MediaMetadataRequest(
      playerId: playerId,
      metadata: metadata
    )
  }
  func toList() -> [Any?] {
    return [
      playerId,
      metadata,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AbrConfigMessage {
  var maxBitrateBps: Int64? = nil
  var minBitrateBps: Int64? = nil
  var preferredMaxWidth: Int64? = nil
  var preferredMaxHeight: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AbrConfigMessage? {
    let maxBitrateBps: Int64? = nilOrValue(pigeonVar_list[0])
    let minBitrateBps: Int64? = nilOrValue(pigeonVar_list[1])
    let preferredMaxWidth: Int64? = nilOrValue(pigeonVar_list[2])
    let preferredMaxHeight: Int64? = nilOrValue(pigeonVar_list[3])

    return AbrConfigMessage(
      maxBitrateBps: maxBitrateBps,
      minBitrateBps: minBitrateBps,
      preferredMaxWidth: preferredMaxWidth,
      preferredMaxHeight: preferredMaxHeight
    )
  }
  func toList() -> [Any?] {
    return [
      maxBitrateBps,
      minBitrateBps,
      preferredMaxWidth,
      preferredMaxHeight,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SetAbrConfigRequest {
  var playerId: Int64
  var config: AbrConfigMessage


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SetAbrConfigRequest? {
    let playerId = pigeonVar_list[0] as! Int64
    let config = pigeonVar_list[1] as! AbrConfigMessage

    return SetAbrConfigRequest(
      playerId: playerId,
      config: config
    )
  }
  func toList() -> [Any?] {
    return [
      playerId,
      config,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DecoderInfoMessage {
  var isHardwareAccelerated: Bool
  var decoderName: String? = nil
  var codec: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DecoderInfoMessage? {
    let isHardwareAccelerated = pigeonVar_list[0] as! Bool
    let decoderName: String? = nilOrValue(pigeonVar_list[1])
    let codec: String? = nilOrValue(pigeonVar_list[2])

    return DecoderInfoMessage(
      isHardwareAccelerated: isHardwareAccelerated,
      decoderName: decoderName,
      codec: codec
    )
  }
  func toList() -> [Any?] {
    return [
      isHardwareAccelerated,
      decoderName,
      codec,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SubtitleTrackMessage {
  var id: String
  var label: String
  var language: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SubtitleTrackMessage? {
    let id = pigeonVar_list[0] as! String
    let label = pigeonVar_list[1] as! String
    let language: String? = nilOrValue(pigeonVar_list[2])

    return SubtitleTrackMessage(
      id: id,
      label: label,
      language: language
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      label,
      language,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SelectSubtitleTrackRequest {
  var playerId: Int64
  var trackId: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SelectSubtitleTrackRequest? {
    let playerId = pigeonVar_list[0] as! Int64
    let trackId: String? = nilOrValue(pigeonVar_list[1])

    return SelectSubtitleTrackRequest(
      playerId: playerId,
      trackId: trackId
    )
  }
  func toList() -> [Any?] {
    return [
      playerId,
      trackId,
    ]
  }
}

private class MessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return SourceType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      return VideoSourceMessage.fromList(self.readValue() as! [Any?])
    case 131:
      return MediaMetadataMessage.fromList(self.readValue() as! [Any?])
    case 132:
      return EnterPipRequest.fromList(self.readValue() as! [Any?])
    case 133:
      return MediaMetadataRequest.fromList(self.readValue() as! [Any?])
    case 134:
      return AbrConfigMessage.fromList(self.readValue() as! [Any?])
    case 135:
      return SetAbrConfigRequest.fromList(self.readValue() as! [Any?])
    case 136:
      return DecoderInfoMessage.fromList(self.readValue() as! [Any?])
    case 137:
      return SubtitleTrackMessage.fromList(self.readValue() as! [Any?])
    case 138:
      return SelectSubtitleTrackRequest.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? SourceType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? VideoSourceMessage {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? MediaMetadataMessage {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? EnterPipRequest {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? MediaMetadataRequest {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? AbrConfigMessage {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? SetAbrConfigRequest {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? DecoderInfoMessage {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? SubtitleTrackMessage {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? SelectSubtitleTrackRequest {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MessagesPigeonCodecWriter(data: data)
  }
}

class MessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MessagesPigeonCodec(readerWriter: MessagesPigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol AvPlayerHostApi {
  func create(source: VideoSourceMessage, completion: @escaping (Result<Int64, Error>) -> Void)
  func dispose(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func play(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func pause(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func seekTo(playerId: Int64, positionMs: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func setPlaybackSpeed(playerId: Int64, speed: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func setLooping(playerId: Int64, looping: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func setVolume(playerId: Int64, volume: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func isPipAvailable(completion: @escaping (Result<Bool, Error>) -> Void)
  func enterPip(request: EnterPipRequest, completion: @escaping (Result<Void, Error>) -> Void)
  func exitPip(playerId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  func setMediaMetadata(request: MediaMetadataRequest, completion: @escaping (Result<Void, Error>) -> Void)
  func setNotificationEnabled(playerId: Int64, enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func setSystemVolume(volume: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getSystemVolume(completion: @escaping (Result<Double, Error>) -> Void)
  func setScreenBrightness(brightness: Double, completion: @escaping (Result<Void, Error>) -> Void)
  func getScreenBrightness(completion: @escaping (Result<Double, Error>) -> Void)
  func setWakelock(enabled: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func setAbrConfig(request: SetAbrConfigRequest, completion: @escaping (Result<Void, Error>) -> Void)
  func getDecoderInfo(playerId: Int64, completion: @escaping (Result<DecoderInfoMessage, Error>) -> Void)
  func getSubtitleTracks(playerId: Int64, completion: @escaping (Result<[SubtitleTrackMessage], Error>) -> Void)
  func selectSubtitleTrack(request: SelectSubtitleTrackRequest, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class AvPlayerHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `AvPlayerHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: AvPlayerHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.create\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let sourceArg = args[0] as! VideoSourceMessage
        api.create(source: sourceArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.dispose\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.dispose(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.play\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.play(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.pause\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.pause(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.seekTo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let positionMsArg = args[1] as! Int64
        api.seekTo(playerId: playerIdArg, positionMs: positionMsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let setPlaybackSpeedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setPlaybackSpeed\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setPlaybackSpeedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let speedArg = args[1] as! Double
        api.setPlaybackSpeed(playerId: playerIdArg, speed: speedArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPlaybackSpeedChannel.setMessageHandler(nil)
    }
    let setLoopingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setLooping\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setLoopingChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let loopingArg = args[1] as! Bool
        api.setLooping(playerId: playerIdArg, looping: loopingArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLoopingChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let volumeArg = args[1] as! Double
        api.setVolume(playerId: playerIdArg, volume: volumeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let isPipAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.isPipAvailable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isPipAvailableChannel.setMessageHandler { _, reply in
        api.isPipAvailable { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isPipAvailableChannel.setMessageHandler(nil)
    }
    let enterPipChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.enterPip\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      enterPipChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! EnterPipRequest
        api.enterPip(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      enterPipChannel.setMessageHandler(nil)
    }
    let exitPipChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.exitPip\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      exitPipChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.exitPip(playerId: playerIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      exitPipChannel.setMessageHandler(nil)
    }
    let setMediaMetadataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setMediaMetadata\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! MediaMetadataRequest
        api.setMediaMetadata(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMediaMetadataChannel.setMessageHandler(nil)
    }
    let setNotificationEnabledChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setNotificationEnabled\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setNotificationEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        let enabledArg = args[1] as! Bool
        api.setNotificationEnabled(playerId: playerIdArg, enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setNotificationEnabledChannel.setMessageHandler(nil)
    }
    let setSystemVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setSystemVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSystemVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let volumeArg = args[0] as! Double
        api.setSystemVolume(volume: volumeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSystemVolumeChannel.setMessageHandler(nil)
    }
    let getSystemVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.getSystemVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSystemVolumeChannel.setMessageHandler { _, reply in
        api.getSystemVolume { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSystemVolumeChannel.setMessageHandler(nil)
    }
    let setScreenBrightnessChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setScreenBrightness\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setScreenBrightnessChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let brightnessArg = args[0] as! Double
        api.setScreenBrightness(brightness: brightnessArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setScreenBrightnessChannel.setMessageHandler(nil)
    }
    let getScreenBrightnessChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.getScreenBrightness\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getScreenBrightnessChannel.setMessageHandler { _, reply in
        api.getScreenBrightness { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getScreenBrightnessChannel.setMessageHandler(nil)
    }
    let setWakelockChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setWakelock\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setWakelockChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let enabledArg = args[0] as! Bool
        api.setWakelock(enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setWakelockChannel.setMessageHandler(nil)
    }
    let setAbrConfigChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.setAbrConfig\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setAbrConfigChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! SetAbrConfigRequest
        api.setAbrConfig(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setAbrConfigChannel.setMessageHandler(nil)
    }
    let getDecoderInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.getDecoderInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDecoderInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getDecoderInfo(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDecoderInfoChannel.setMessageHandler(nil)
    }
    let getSubtitleTracksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.getSubtitleTracks\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getSubtitleTracksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let playerIdArg = args[0] as! Int64
        api.getSubtitleTracks(playerId: playerIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getSubtitleTracksChannel.setMessageHandler(nil)
    }
    let selectSubtitleTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.av_player.AvPlayerHostApi.selectSubtitleTrack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      selectSubtitleTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! SelectSubtitleTrackRequest
        api.selectSubtitleTrack(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      selectSubtitleTrackChannel.setMessageHandler(nil)
    }
  }
}
